/**\n * Post Reading Screen Component for The Nullary\n * Dedicated full-screen interface for reading blog posts\n */\n\nimport { createLayeredUI } from '../utils/layered-ui.js';\nimport { createBlogViewer } from '../components/blog-viewer.js';\n\n/**\n * Default post reading screen configuration\n */\nconst DEFAULT_POST_READING_SCREEN_CONFIG = {\n  // Screen metadata\n  title: 'Reading Post',\n  \n  // Layout\n  width: '100%',\n  height: '100vh',\n  \n  // Theme\n  theme: {\n    colors: {\n      background: '#ffffff',\n      surface: '#f8fafc',\n      primary: '#3b82f6',\n      secondary: '#64748b',\n      accent: '#10b981',\n      text: '#1e293b',\n      textSecondary: '#64748b',\n      border: '#e2e8f0',\n      success: '#10b981',\n      warning: '#f59e0b',\n      error: '#ef4444'\n    },\n    typography: {\n      fontFamily: 'Georgia, serif',\n      fontSize: 16,\n      titleSize: 32,\n      headerSize: 28,\n      contentLineHeight: 1.7\n    }\n  },\n  \n  // Features\n  features: {\n    showBackButton: true,\n    showShareButton: true,\n    showBookmarkButton: true,\n    showPrintButton: true,\n    showProgressBar: true,\n    enableReadingMode: true,\n    enableFullscreen: true,\n    showTableOfContents: false\n  },\n  \n  // Reader settings\n  reader: {\n    maxContentWidth: 800,\n    contentPadding: 60,\n    enableScrollTracking: true,\n    autoHideControls: true,\n    hideDelay: 3000\n  },\n  \n  // Navigation\n  navigation: {\n    showPrevNext: false,\n    enableKeyboardNav: true,\n    enableSwipeGestures: false\n  }\n};\n\n/**\n * Create post reading screen component\n * @param {Object} blogPost - Blog post data\n * @param {Object} config - Configuration object\n * @returns {Object} Post reading screen component with methods\n */\nexport function createPostReadingScreen(blogPost, config = {}) {\n  const finalConfig = { ...DEFAULT_POST_READING_SCREEN_CONFIG, ...config };\n  \n  // Screen state\n  const screenState = {\n    blogPost,\n    isLoading: false,\n    error: null,\n    scrollProgress: 0,\n    isFullscreen: false,\n    readingTime: 0,\n    startTime: Date.now(),\n    controlsVisible: true,\n    layeredUI: null,\n    blogViewer: null,\n    hideTimeout: null\n  };\n  \n  // Event handlers\n  const eventHandlers = {\n    onBack: null,\n    onShare: null,\n    onBookmark: null,\n    onProgress: null,\n    onComplete: null\n  };\n  \n  // Create layered UI\n  function createUI() {\n    screenState.layeredUI = createLayeredUI({\n      className: 'post-reading-screen-ui',\n      width: finalConfig.width,\n      height: finalConfig.height,\n      layers: [\n        {\n          id: 'background',\n          type: 'div',\n          zIndex: 1,\n          config: {\n            backgroundColor: finalConfig.theme.colors.background\n          }\n        },\n        {\n          id: 'content-area',\n          type: 'div',\n          zIndex: 100,\n          config: {\n            backgroundColor: 'transparent',\n            width: '100%',\n            height: '100%',\n            position: 'relative'\n          }\n        },\n        {\n          id: 'controls-hud',\n          type: 'hud',\n          zIndex: 1000,\n          config: {\n            background: 'rgba(248, 250, 252, 0.95)',\n            transparentZones: [\n              {\n                x: 0,\n                y: 80,\n                width: '100%',\n                height: 'calc(100% - 160px)',\n                shape: 'rect'\n              }\n            ],\n            elements: [\n              // Top controls\n              {\n                id: 'back-button',\n                type: 'button',\n                x: 20,\n                y: 20,\n                width: 100,\n                height: 40,\n                content: 'â† Back',\n                backgroundColor: 'rgba(100, 116, 139, 0.1)',\n                borderColor: finalConfig.theme.colors.secondary,\n                color: finalConfig.theme.colors.secondary,\n                onClick: () => handleBack()\n              },\n              {\n                id: 'post-title',\n                type: 'text',\n                x: 140,\n                y: 25,\n                content: blogPost.title,\n                color: finalConfig.theme.colors.text,\n                fontSize: 18,\n                fontFamily: finalConfig.theme.typography.fontFamily,\n                maxWidth: 'calc(100% - 400px)'\n              },\n              {\n                id: 'share-button',\n                type: 'button',\n                x: 'calc(100% - 320px)',\n                y: 20,\n                width: 80,\n                height: 40,\n                content: 'ðŸ”— Share',\n                backgroundColor: finalConfig.theme.colors.accent,\n                color: '#ffffff',\n                onClick: () => handleShare()\n              },\n              {\n                id: 'bookmark-button',\n                type: 'button',\n                x: 'calc(100% - 230px)',\n                y: 20,\n                width: 100,\n                height: 40,\n                content: 'ðŸ”– Bookmark',\n                backgroundColor: finalConfig.theme.colors.primary,\n                color: '#ffffff',\n                onClick: () => handleBookmark()\n              },\n              {\n                id: 'fullscreen-button',\n                type: 'button',\n                x: 'calc(100% - 120px)',\n                y: 20,\n                width: 100,\n                height: 40,\n                content: 'â›¶ Fullscreen',\n                backgroundColor: 'rgba(100, 116, 139, 0.1)',\n                color: finalConfig.theme.colors.secondary,\n                onClick: () => toggleFullscreen()\n              },\n              \n              // Bottom controls\n              {\n                id: 'reading-progress',\n                type: 'progress',\n                x: 20,\n                y: 'calc(100% - 50px)',\n                width: 'calc(100% - 200px)',\n                height: 4,\n                progress: 0,\n                color: finalConfig.theme.colors.primary,\n                backgroundColor: 'rgba(59, 130, 246, 0.1)'\n              },\n              {\n                id: 'reading-time',\n                type: 'text',\n                x: 'calc(100% - 170px)',\n                y: 'calc(100% - 45px)',\n                content: '0 min read',\n                color: finalConfig.theme.colors.textSecondary,\n                fontSize: 12\n              }\n            ]\n          }\n        }\n      ]\n    });\n    \n    return screenState.layeredUI;\n  }\n  \n  // Setup blog viewer in content area\n  function setupBlogViewer() {\n    const contentLayer = screenState.layeredUI.getLayer('content-area');\n    if (!contentLayer) return;\n    \n    // Create blog viewer without its own header (we're using HUD)\n    screenState.blogViewer = createBlogViewer(blogPost, {\n      width: '100%',\n      height: '100%',\n      showHeader: false,\n      showBackButton: false,\n      contentPadding: finalConfig.reader.contentPadding,\n      maxContentWidth: finalConfig.reader.maxContentWidth,\n      theme: finalConfig.theme\n    });\n    \n    // Setup viewer event handlers\n    screenState.blogViewer.onLoad(() => {\n      console.log('ðŸ“– Blog post loaded');\n      updateReadingTime();\n      \n      if (finalConfig.reader.enableScrollTracking) {\n        setupScrollTracking();\n      }\n    });\n    \n    screenState.blogViewer.onError((error) => {\n      console.error('âŒ Error loading blog post:', error);\n      showMessage(`Error loading post: ${error}`, 'error');\n    });\n    \n    contentLayer.component.element.appendChild(screenState.blogViewer.element);\n  }\n  \n  // Setup scroll tracking for progress\n  function setupScrollTracking() {\n    const contentElement = screenState.blogViewer.element;\n    if (!contentElement) return;\n    \n    const scrollContainer = contentElement.querySelector('.hosted-content-container') || \n                           contentElement.querySelector('.external-iframe-container');\n    \n    if (scrollContainer) {\n      scrollContainer.addEventListener('scroll', (e) => {\n        const { scrollTop, scrollHeight, clientHeight } = e.target;\n        const progress = scrollHeight > clientHeight ? scrollTop / (scrollHeight - clientHeight) : 0;\n        \n        screenState.scrollProgress = Math.min(Math.max(progress, 0), 1);\n        updateProgressBar();\n        \n        // Auto-hide controls when scrolling\n        if (finalConfig.reader.autoHideControls) {\n          showControls();\n          resetHideTimeout();\n        }\n        \n        if (eventHandlers.onProgress) {\n          eventHandlers.onProgress(screenState.scrollProgress);\n        }\n        \n        // Check if reading is complete\n        if (progress > 0.9 && eventHandlers.onComplete) {\n          eventHandlers.onComplete({\n            readingTime: screenState.readingTime,\n            scrollProgress: screenState.scrollProgress\n          });\n        }\n      });\n    }\n  }\n  \n  // Handle back navigation\n  function handleBack() {\n    if (eventHandlers.onBack) {\n      eventHandlers.onBack();\n    }\n  }\n  \n  // Handle share\n  function handleShare() {\n    if (navigator.share && blogPost.productUrl) {\n      navigator.share({\n        title: blogPost.title,\n        text: blogPost.description,\n        url: blogPost.productUrl\n      }).catch(console.error);\n    } else {\n      // Fallback: copy to clipboard\n      const shareText = `${blogPost.title} - ${blogPost.productUrl || window.location.href}`;\n      navigator.clipboard.writeText(shareText).then(() => {\n        showMessage('âœ… Link copied to clipboard', 'success');\n      }).catch(() => {\n        showMessage('âŒ Failed to copy link', 'error');\n      });\n    }\n    \n    if (eventHandlers.onShare) {\n      eventHandlers.onShare(blogPost);\n    }\n  }\n  \n  // Handle bookmark\n  function handleBookmark() {\n    // Implement your bookmarking logic here\n    showMessage('ðŸ”– Post bookmarked', 'success');\n    \n    if (eventHandlers.onBookmark) {\n      eventHandlers.onBookmark(blogPost);\n    }\n  }\n  \n  // Toggle fullscreen\n  function toggleFullscreen() {\n    if (!document.fullscreenElement) {\n      document.documentElement.requestFullscreen().then(() => {\n        screenState.isFullscreen = true;\n        updateFullscreenButton('â›¶ Exit Fullscreen');\n      }).catch(console.error);\n    } else {\n      document.exitFullscreen().then(() => {\n        screenState.isFullscreen = false;\n        updateFullscreenButton('â›¶ Fullscreen');\n      }).catch(console.error);\n    }\n  }\n  \n  // Update reading time\n  function updateReadingTime() {\n    const updateTimer = () => {\n      screenState.readingTime = Math.floor((Date.now() - screenState.startTime) / 1000 / 60);\n      updateReadingTimeDisplay();\n    };\n    \n    updateTimer();\n    setInterval(updateTimer, 30000); // Update every 30 seconds\n  }\n  \n  // Update HUD elements\n  function updateProgressBar() {\n    if (screenState.layeredUI) {\n      screenState.layeredUI.updateHUDElement('reading-progress', {\n        progress: screenState.scrollProgress\n      });\n    }\n  }\n  \n  function updateReadingTimeDisplay() {\n    if (screenState.layeredUI) {\n      const timeText = screenState.readingTime > 0 ? \n        `${screenState.readingTime} min read` : \n        'Just started';\n      \n      screenState.layeredUI.updateHUDElement('reading-time', {\n        content: timeText\n      });\n    }\n  }\n  \n  function updateFullscreenButton(text) {\n    if (screenState.layeredUI) {\n      screenState.layeredUI.updateHUDElement('fullscreen-button', {\n        content: text\n      });\n    }\n  }\n  \n  // Controls visibility\n  function showControls() {\n    if (!screenState.controlsVisible) {\n      screenState.controlsVisible = true;\n      \n      if (screenState.layeredUI) {\n        const hudLayer = screenState.layeredUI.getHUDLayer();\n        if (hudLayer) {\n          hudLayer.component.show();\n        }\n      }\n    }\n  }\n  \n  function hideControls() {\n    if (screenState.controlsVisible && finalConfig.reader.autoHideControls) {\n      screenState.controlsVisible = false;\n      \n      if (screenState.layeredUI) {\n        const hudLayer = screenState.layeredUI.getHUDLayer();\n        if (hudLayer) {\n          hudLayer.component.hide();\n        }\n      }\n    }\n  }\n  \n  function resetHideTimeout() {\n    if (screenState.hideTimeout) {\n      clearTimeout(screenState.hideTimeout);\n    }\n    \n    screenState.hideTimeout = setTimeout(() => {\n      hideControls();\n    }, finalConfig.reader.hideDelay);\n  }\n  \n  // Setup keyboard navigation\n  function setupKeyboardNavigation() {\n    const keyHandler = (e) => {\n      switch (e.key) {\n        case 'Escape':\n          if (screenState.isFullscreen) {\n            toggleFullscreen();\n          } else {\n            handleBack();\n          }\n          break;\n          \n        case 'f':\n        case 'F':\n          if (e.ctrlKey || e.metaKey) {\n            e.preventDefault();\n            toggleFullscreen();\n          }\n          break;\n          \n        case 's':\n        case 'S':\n          if (e.ctrlKey || e.metaKey) {\n            e.preventDefault();\n            handleShare();\n          }\n          break;\n          \n        case 'b':\n        case 'B':\n          if (e.ctrlKey || e.metaKey) {\n            e.preventDefault();\n            handleBookmark();\n          }\n          break;\n          \n        case ' ': // Spacebar for show/hide controls\n          e.preventDefault();\n          if (screenState.controlsVisible) {\n            hideControls();\n          } else {\n            showControls();\n            resetHideTimeout();\n          }\n          break;\n      }\n    };\n    \n    document.addEventListener('keydown', keyHandler);\n    \n    // Return cleanup function\n    return () => {\n      document.removeEventListener('keydown', keyHandler);\n    };\n  }\n  \n  // Show message\n  function showMessage(text, type = 'info') {\n    const messageEl = document.createElement('div');\n    messageEl.style.cssText = `\n      position: fixed;\n      top: 20px;\n      left: 50%;\n      transform: translateX(-50%);\n      z-index: 3000;\n      padding: 12px 24px;\n      border-radius: 8px;\n      font-family: Arial, sans-serif;\n      font-size: 14px;\n      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);\n      opacity: 0;\n      transition: opacity 0.3s ease;\n      background: ${type === 'error' ? '#fef2f2' : type === 'success' ? '#f0fdf4' : '#eff6ff'};\n      color: ${type === 'error' ? '#991b1b' : type === 'success' ? '#166534' : '#1e40af'};\n      border: 1px solid ${type === 'error' ? '#fecaca' : type === 'success' ? '#bbf7d0' : '#dbeafe'};\n    `;\n    messageEl.textContent = text;\n    \n    document.body.appendChild(messageEl);\n    \n    setTimeout(() => messageEl.style.opacity = '1', 100);\n    setTimeout(() => {\n      messageEl.style.opacity = '0';\n      setTimeout(() => {\n        if (messageEl.parentNode) {\n          messageEl.parentNode.removeChild(messageEl);\n        }\n      }, 300);\n    }, 3000);\n  }\n  \n  // Screen interface\n  const postReadingScreen = {\n    element: null,\n    \n    // Initialization\n    initialize() {\n      console.log('ðŸ—ï¸ Initializing post reading screen...');\n      \n      // Create UI\n      const ui = createUI();\n      this.element = ui.element;\n      \n      // Setup blog viewer\n      setupBlogViewer();\n      \n      // Setup keyboard navigation\n      if (finalConfig.navigation.enableKeyboardNav) {\n        this.cleanupKeyboard = setupKeyboardNavigation();\n      }\n      \n      // Initialize auto-hide timeout\n      if (finalConfig.reader.autoHideControls) {\n        resetHideTimeout();\n        \n        // Show controls on mouse movement\n        this.element.addEventListener('mousemove', () => {\n          showControls();\n          resetHideTimeout();\n        });\n      }\n      \n      console.log('âœ… Post reading screen initialized');\n      return this;\n    },\n    \n    // Blog post management\n    getBlogPost() {\n      return screenState.blogPost;\n    },\n    \n    updateBlogPost(newBlogPost) {\n      screenState.blogPost = newBlogPost;\n      if (screenState.blogViewer) {\n        screenState.blogViewer.updateBlogPost(newBlogPost);\n      }\n      \n      // Update HUD title\n      if (screenState.layeredUI) {\n        screenState.layeredUI.updateHUDElement('post-title', {\n          content: newBlogPost.title\n        });\n      }\n    },\n    \n    // State access\n    getReadingProgress() {\n      return screenState.scrollProgress;\n    },\n    \n    getReadingTime() {\n      return screenState.readingTime;\n    },\n    \n    isFullscreen() {\n      return screenState.isFullscreen;\n    },\n    \n    // Event handlers\n    onBack(handler) {\n      eventHandlers.onBack = handler;\n    },\n    \n    onShare(handler) {\n      eventHandlers.onShare = handler;\n    },\n    \n    onBookmark(handler) {\n      eventHandlers.onBookmark = handler;\n    },\n    \n    onProgress(handler) {\n      eventHandlers.onProgress = handler;\n    },\n    \n    onComplete(handler) {\n      eventHandlers.onComplete = handler;\n    },\n    \n    // Actions\n    triggerShare() {\n      handleShare();\n    },\n    \n    triggerBookmark() {\n      handleBookmark();\n    },\n    \n    triggerFullscreen() {\n      toggleFullscreen();\n    },\n    \n    showControls() {\n      showControls();\n      resetHideTimeout();\n    },\n    \n    hideControls() {\n      hideControls();\n    },\n    \n    // Cleanup\n    destroy() {\n      if (this.cleanupKeyboard) {\n        this.cleanupKeyboard();\n      }\n      \n      if (screenState.hideTimeout) {\n        clearTimeout(screenState.hideTimeout);\n      }\n      \n      if (this.element && this.element.parentNode) {\n        this.element.parentNode.removeChild(this.element);\n      }\n    }\n  };\n  \n  return postReadingScreen;\n}\n\n/**\n * Export default configuration\n */\nexport { DEFAULT_POST_READING_SCREEN_CONFIG as postReadingScreenDefaults };