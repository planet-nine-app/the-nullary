/**\n * Sanora Integration Utilities for The Nullary\n * Handles blog post creation, upload, and management with Sanora service\n */\n\n/**\n * Default Sanora configuration\n */\nconst DEFAULT_SANORA_CONFIG = {\n  baseUrl: 'http://127.0.0.1:7243',\n  endpoints: {\n    createUser: '/user/create',\n    createProduct: '/product/create',\n    uploadImage: '/image/upload',\n    uploadContent: '/content/upload',\n    getProducts: '/products',\n    getProduct: '/product'\n  },\n  \n  // File upload settings\n  maxImageSize: 5 * 1024 * 1024, // 5MB\n  maxContentSize: 50 * 1024 * 1024, // 50MB\n  allowedImageTypes: ['image/jpeg', 'image/png', 'image/webp'],\n  allowedContentTypes: ['.md', '.html', '.txt', '.pdf'],\n  \n  // Product defaults\n  defaultCurrency: 'USD',\n  defaultType: 'blog'\n};\n\n/**\n * Sanora client class\n */\nexport class SanoraClient {\n  constructor(config = {}) {\n    this.config = { ...DEFAULT_SANORA_CONFIG, ...config };\n    this.user = null;\n    this.sessionlessKeys = null;\n  }\n  \n  /**\n   * Initialize the client with sessionless keys\n   * @param {Object} keys - Sessionless keys (pubKey, privKey)\n   */\n  async initialize(keys) {\n    this.sessionlessKeys = keys;\n    \n    try {\n      // Create or get user\n      this.user = await this.createUser(keys.pubKey);\n      console.log('ðŸŒ Sanora client initialized for user:', this.user.uuid);\n      return true;\n    } catch (error) {\n      console.error('âŒ Failed to initialize Sanora client:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Create or get existing user\n   * @param {string} pubKey - Public key\n   * @returns {Object} User object\n   */\n  async createUser(pubKey) {\n    const response = await fetch(`${this.config.baseUrl}${this.config.endpoints.createUser}`, {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ pubKey })\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Failed to create user: ${response.statusText}`);\n    }\n    \n    return await response.json();\n  }\n  \n  /**\n   * Upload an image file\n   * @param {File} imageFile - Image file to upload\n   * @returns {Object} Upload result with filename\n   */\n  async uploadImage(imageFile) {\n    if (!this.user) {\n      throw new Error('Client not initialized. Call initialize() first.');\n    }\n    \n    // Validate file\n    if (imageFile.size > this.config.maxImageSize) {\n      throw new Error(`Image file too large. Maximum size: ${this.config.maxImageSize / 1024 / 1024}MB`);\n    }\n    \n    if (!this.config.allowedImageTypes.includes(imageFile.type)) {\n      throw new Error(`Invalid image type. Allowed types: ${this.config.allowedImageTypes.join(', ')}`);\n    }\n    \n    const formData = new FormData();\n    formData.append('image', imageFile);\n    formData.append('uuid', this.user.uuid);\n    \n    const response = await fetch(`${this.config.baseUrl}${this.config.endpoints.uploadImage}`, {\n      method: 'POST',\n      body: formData\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Failed to upload image: ${response.statusText}`);\n    }\n    \n    return await response.json();\n  }\n  \n  /**\n   * Upload a content file (markdown, HTML, etc.)\n   * @param {File} contentFile - Content file to upload\n   * @returns {Object} Upload result with filename\n   */\n  async uploadContent(contentFile) {\n    if (!this.user) {\n      throw new Error('Client not initialized. Call initialize() first.');\n    }\n    \n    // Validate file\n    if (contentFile.size > this.config.maxContentSize) {\n      throw new Error(`Content file too large. Maximum size: ${this.config.maxContentSize / 1024 / 1024}MB`);\n    }\n    \n    const fileExtension = '.' + contentFile.name.split('.').pop().toLowerCase();\n    if (!this.config.allowedContentTypes.includes(fileExtension)) {\n      throw new Error(`Invalid content type. Allowed types: ${this.config.allowedContentTypes.join(', ')}`);\n    }\n    \n    const formData = new FormData();\n    formData.append('content', contentFile);\n    formData.append('uuid', this.user.uuid);\n    \n    const response = await fetch(`${this.config.baseUrl}${this.config.endpoints.uploadContent}`, {\n      method: 'POST',\n      body: formData\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Failed to upload content: ${response.statusText}`);\n    }\n    \n    return await response.json();\n  }\n  \n  /**\n   * Create a blog product on Sanora\n   * @param {Object} blogData - Blog post data\n   * @returns {Object} Created product\n   */\n  async createBlogProduct(blogData) {\n    if (!this.user) {\n      throw new Error('Client not initialized. Call initialize() first.');\n    }\n    \n    const {\n      title,\n      description,\n      author,\n      publishDate,\n      price = null,\n      previewImageFile = null,\n      contentFile = null,\n      externalUrl = null,\n      type = 'hosted'\n    } = blogData;\n    \n    let imageFilename = null;\n    let contentFilename = null;\n    \n    try {\n      // Upload preview image if provided\n      if (previewImageFile) {\n        const imageResult = await this.uploadImage(previewImageFile);\n        imageFilename = imageResult.filename;\n      }\n      \n      // Upload content file for hosted blogs\n      if (type === 'hosted' && contentFile) {\n        const contentResult = await this.uploadContent(contentFile);\n        contentFilename = contentResult.filename;\n      }\n      \n      // Prepare product data\n      const productData = {\n        uuid: this.user.uuid,\n        title,\n        description: `${description}\\n\\nBy ${author} â€¢ Published ${new Date(publishDate).toLocaleDateString()}`,\n        price: price ? Math.round(price * 100) : 0, // Convert to cents\n        image: imageFilename,\n        content: contentFilename,\n        redirectUrl: type === 'external' ? externalUrl : null,\n        type: this.config.defaultType,\n        metadata: {\n          author,\n          publishDate,\n          blogType: type,\n          externalUrl: type === 'external' ? externalUrl : null\n        }\n      };\n      \n      // Create product\n      const response = await fetch(`${this.config.baseUrl}${this.config.endpoints.createProduct}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(productData)\n      });\n      \n      if (!response.ok) {\n        throw new Error(`Failed to create product: ${response.statusText}`);\n      }\n      \n      const product = await response.json();\n      \n      // Enhance product with blog-specific data\n      return {\n        ...product,\n        blogData: {\n          title,\n          description,\n          author,\n          publishDate,\n          type,\n          previewImage: imageFilename ? `${this.config.baseUrl}/images/${imageFilename}` : null,\n          contentUrl: contentFilename ? `${this.config.baseUrl}/content/${contentFilename}` : null,\n          externalUrl: type === 'external' ? externalUrl : null,\n          productUrl: `${this.config.baseUrl}/product/${product.uuid}`,\n          price: price\n        }\n      };\n      \n    } catch (error) {\n      console.error('âŒ Error creating blog product:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Get all products for the current user\n   * @returns {Array} Array of products\n   */\n  async getUserProducts() {\n    if (!this.user) {\n      throw new Error('Client not initialized. Call initialize() first.');\n    }\n    \n    const response = await fetch(`${this.config.baseUrl}${this.config.endpoints.getProducts}?uuid=${this.user.uuid}`);\n    \n    if (!response.ok) {\n      throw new Error(`Failed to get products: ${response.statusText}`);\n    }\n    \n    const products = await response.json();\n    \n    // Transform products to blog preview format\n    return products.map(product => this.transformProductToBlogPreview(product));\n  }\n  \n  /**\n   * Get all blog products from multiple users/bases\n   * @param {Array} userUuids - Array of user UUIDs to fetch from\n   * @returns {Array} Array of blog previews\n   */\n  async getBlogPreviews(userUuids = []) {\n    try {\n      const allPreviews = [];\n      \n      // If no specific users provided, get public products\n      if (userUuids.length === 0) {\n        const response = await fetch(`${this.config.baseUrl}${this.config.endpoints.getProducts}`);\n        if (response.ok) {\n          const products = await response.json();\n          allPreviews.push(...products.map(product => this.transformProductToBlogPreview(product)));\n        }\n      } else {\n        // Fetch products for specific users\n        const fetchPromises = userUuids.map(async (uuid) => {\n          try {\n            const response = await fetch(`${this.config.baseUrl}${this.config.endpoints.getProducts}?uuid=${uuid}`);\n            if (response.ok) {\n              const products = await response.json();\n              return products.map(product => this.transformProductToBlogPreview(product));\n            }\n          } catch (error) {\n            console.warn(`Failed to fetch products for user ${uuid}:`, error);\n          }\n          return [];\n        });\n        \n        const results = await Promise.all(fetchPromises);\n        results.forEach(previews => allPreviews.push(...previews));\n      }\n      \n      // Sort by publish date (newest first)\n      return allPreviews.sort((a, b) => new Date(b.publishDate) - new Date(a.publishDate));\n      \n    } catch (error) {\n      console.error('âŒ Error fetching blog previews:', error);\n      return [];\n    }\n  }\n  \n  /**\n   * Transform Sanora product to blog preview format\n   * @param {Object} product - Sanora product object\n   * @returns {Object} Blog preview object\n   */\n  transformProductToBlogPreview(product) {\n    const metadata = product.metadata || {};\n    \n    return {\n      id: product.uuid,\n      title: product.title,\n      description: product.description.split('\\n')[0], // Get first line as description\n      author: metadata.author || 'Unknown Author',\n      publishDate: metadata.publishDate || product.createdAt || new Date().toISOString(),\n      type: metadata.blogType || 'hosted',\n      previewImage: product.image ? `${this.config.baseUrl}/images/${product.image}` : null,\n      price: product.price > 0 ? product.price : null,\n      externalUrl: metadata.externalUrl || product.redirectUrl,\n      productUrl: `${this.config.baseUrl}/product/${product.uuid}`,\n      contentUrl: product.content ? `${this.config.baseUrl}/content/${product.content}` : null,\n      sanÐ¾Ñ€Ð°Product: product // Keep original product data\n    };\n  }\n  \n  /**\n   * Get a specific product by UUID\n   * @param {string} productUuid - Product UUID\n   * @returns {Object} Product object\n   */\n  async getProduct(productUuid) {\n    const response = await fetch(`${this.config.baseUrl}${this.config.endpoints.getProduct}/${productUuid}`);\n    \n    if (!response.ok) {\n      throw new Error(`Failed to get product: ${response.statusText}`);\n    }\n    \n    return await response.json();\n  }\n  \n  /**\n   * Delete a product\n   * @param {string} productUuid - Product UUID to delete\n   * @returns {boolean} Success status\n   */\n  async deleteProduct(productUuid) {\n    if (!this.user) {\n      throw new Error('Client not initialized. Call initialize() first.');\n    }\n    \n    const response = await fetch(`${this.config.baseUrl}/product/delete`, {\n      method: 'DELETE',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        uuid: this.user.uuid,\n        productUuid\n      })\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Failed to delete product: ${response.statusText}`);\n    }\n    \n    return true;\n  }\n  \n  /**\n   * Get user info\n   * @returns {Object} Current user object\n   */\n  getUser() {\n    return this.user;\n  }\n  \n  /**\n   * Check if client is initialized\n   * @returns {boolean} Initialization status\n   */\n  isInitialized() {\n    return this.user !== null && this.sessionlessKeys !== null;\n  }\n}\n\n/**\n * Create a mock Sanora client for development/testing\n * @param {Object} config - Configuration object\n * @returns {Object} Mock Sanora client\n */\nexport function createMockSanoraClient(config = {}) {\n  let mockProducts = [\n    {\n      uuid: 'blog-1',\n      title: 'Getting Started with The Nullary',\n      description: 'A comprehensive guide to building SVG-based applications with The Nullary ecosystem.',\n      author: 'Developer',\n      publishDate: '2024-01-15',\n      type: 'hosted',\n      previewImage: null,\n      price: null,\n      productUrl: 'https://example.com/blog/getting-started',\n      contentUrl: 'https://example.com/content/getting-started.md'\n    },\n    {\n      uuid: 'blog-2',\n      title: 'Advanced SVG Animations',\n      description: 'Learn how to create stunning animations using SVG and the layered UI system.',\n      author: 'Design Team',\n      publishDate: '2024-01-20',\n      type: 'hosted',\n      previewImage: null,\n      price: 299, // $2.99\n      productUrl: 'https://example.com/blog/svg-animations',\n      contentUrl: 'https://example.com/content/svg-animations.md'\n    },\n    {\n      uuid: 'blog-3',\n      title: 'External Blog Example',\n      description: 'This is an example of a blog post hosted externally and displayed via iframe.',\n      author: 'External Author',\n      publishDate: '2024-01-25',\n      type: 'external',\n      previewImage: null,\n      price: null,\n      externalUrl: 'https://example.com/external-blog',\n      productUrl: 'https://example.com/external-blog'\n    }\n  ];\n  \n  return {\n    async initialize(keys) {\n      console.log('ðŸ§ª Mock Sanora client initialized');\n      return true;\n    },\n    \n    async createBlogProduct(blogData) {\n      const product = {\n        uuid: 'blog-' + Date.now(),\n        ...blogData,\n        id: 'blog-' + Date.now(),\n        productUrl: 'https://example.com/blog/' + Date.now(),\n        contentUrl: blogData.type === 'hosted' ? 'https://example.com/content/' + Date.now() + '.md' : null\n      };\n      \n      mockProducts.unshift(product);\n      \n      console.log('ðŸ§ª Mock blog product created:', product.title);\n      return { blogData: product };\n    },\n    \n    async getBlogPreviews() {\n      console.log('ðŸ§ª Fetching mock blog previews');\n      return [...mockProducts];\n    },\n    \n    async getUserProducts() {\n      return [...mockProducts];\n    },\n    \n    async deleteProduct(productUuid) {\n      mockProducts = mockProducts.filter(p => p.uuid !== productUuid);\n      console.log('ðŸ§ª Mock product deleted:', productUuid);\n      return true;\n    },\n    \n    isInitialized() {\n      return true;\n    },\n    \n    getUser() {\n      return { uuid: 'mock-user-123' };\n    }\n  };\n}\n\n/**\n * Utility function to create Sanora client with sessionless integration\n * @param {Object} sessionlessKeys - Sessionless keys\n * @param {Object} config - Sanora configuration\n * @returns {SanoraClient} Initialized Sanora client\n */\nexport async function createSanoraClient(sessionlessKeys, config = {}) {\n  const client = new SanoraClient(config);\n  const initialized = await client.initialize(sessionlessKeys);\n  \n  if (!initialized) {\n    throw new Error('Failed to initialize Sanora client');\n  }\n  \n  return client;\n}\n\n/**\n * Export default configuration\n */\nexport { DEFAULT_SANORA_CONFIG as sanoraDefaults };